~ "../../hypertext.ua/html.ua"
  ~ Code Div Hâ‚ Hâ‚‚ LI P UL
~ "../../base" ~ Layout

CodeBlock â† # TODO: uiua code block

# code type content ? payload
# Route! GET /lenia/
It â† "200 OK" "text/html" utfâ‚ˆ Layout {}â‹…{
  Hâ‚ "Lenia in Uiua"

  P $ I initially learned of Conway's Game of Life, and
    $ eventually saw a video about Lenia on the internet.
    $ I was immediately intrigued, but at the time I was
    $ not capable of implementing it myself.
    $ 
    $ I was working a lot with Uiua because of Advent of Code
    $ 2024, which led to working with simple cellular automata.
    $ This then caused me to look further into Lenia, where I
    $ discovered a great tutorial, which walked through a Python
    $ implementation. Luckily, Numpy was used, so translation
    $ was rather simple.

  P $ We start off by defining a couple of helper functions:
  UL {
    LI Div {
      P $ First, a function to create a grid of distances to the
        $ origin, for use in kernel generation.
      Code $ Grid â† âŒµË™âŠâ„‚-âŠƒÃ·â‚‚â‡¡
    }
    LI Div {
      P $ This function rotates an array to make its center
        $ appear along the edges of the array.
        $ To apply the fourier transformation correctly,
        $ we need to shift the kernel like this.
      Code $ Shift â† â†»âŒˆÃ·â‚‚âŠ¸â–³
    }
    LI Div {
      P $ This is the central piece that makes running this viable:
      Code $ Conv  â† Ã—âˆš/Ã—âŠ¸â–³ â—ŒÂ°â„‚ âœâˆ©fftÃ—
      P $ This function convolves two arrays (of the same shape).
        $ We only care about the real part, so we can ignore the
        $ imaginary component. Because of the way Uiua's FFT works,
        $ we need to scale everything by the number of
        $ elements. `length deshape` would also work, but this
        $ way is much faster (unless optimized).
    }
    LI Div {
      P $ This is just a simple bell curve.
      Code $ Bell â† â‚‘Â¯Ã·âŸœâ¿2ËœÃ·Ëœ-
    }
  }

  P $ With those functions at our disposal, we can now begin
    $ working on the main Lenia logic. For now, we will focus
    $ on a single channel of states.

  UL {
    LI Div {
      P $ We need to generate a ring kernel, based on the following factors:
      UL {
        LI $ the kernel radius R
        LI $ the world size Ws
        LI $ the kernel peaks Î²
      }
      P $ Here's the code that does this for us:
      Code $ Kernel â† memo(
           $   Ã—â—¡â‹…â§» Ã·âŠ™Grid
           $   Ã—âŠƒ(â¬š0âŠâŒŠ|Bell âŠ™0.5 âŠ™0.15 â—¿â‚)
           $   Shift Ã·/+âŠ¸â™­
           $ )
      P $ We memoize the kernel generation, to save some time later.
        $ We start by making a grid of the specified world size,
        $ then scale it by the inverse kernel radius, and the number
        $ of peaks. Now we do two actions:
      UL {
        LI $ We select from the peak heights, filling with 0 when
           $ the points are too far away.
        LI $ We apply the bell curve function to the decimal part of the distance.
      }
      P $ These two masks are then multiplied. This creates rings at certain radii
        $ with the given peaks. We divide all values by their sum, s.t. the sum
        $ is 1 afterwards. Finally, we shift the kernel for convolution.
    }

    LI Div {
      P $ The heart of the simulation is the step function. It has the
        $ following parameters:
      UL {
        LI $ the world state W (must be a square grid)
        LI $ the time scale T
        LI $ the kernel radi(i/us) R
        LI $ the (sets of) kernel peaks Î²
        LI $ the growth center(s) Î¼
        LI $ the growth width(s) Ïƒ
      }
      P $ All inputs can be supplied once or per kernel.
        $ Here's the code:
      Code $ # W ? W R Î² Î¼ Ïƒ T
           $ U â† â†¥â‚€â†§â‚ +âŸœ(
           $   âŠƒâ¤™âŠ“â§»â—Œğ„ËœâŠ™Â¤
           $   â‰¡(Convâ—‡Kernel)
           $   Ã·âŠƒ(Ã—â§»|/+) -â‚Ã—â‚‚Bell
           $ )
      P $ We start off by getting the world size and preparing some things for
        $ the convolutions. We then generate the kernels and convolve each
        $ with the original world state. Next, we apply the bell function with
        $ relevant growth centers and widths and readjust the output slightly.
        $ Finally, we divide the sum of the convolutions by the number of kernels
        $ and the time step.
        $ This represents the change of the current step, so we add it to the
        $ original world state and clamp the values to [0, 1]
    }

    LI Div {
      P $ Simulating a number of frames is now trivial:
      Code $ Sim â† â¥â¤šâŠ¸â‚…U
      P $ The inputs are the same as `U`, plus the number of frames up front.
    }
  }
}

# $ # In the multi channel version, the output is
# $ # inherently colored.
# $ â”Œâ”€â•´Multi
# $   # Ws R Ï Î²
# $   Kernel â† memo(
# $     Ã—â—¡â‹…â§» Ã·âŠƒâ‹…Ã—Grid
# $     Ã—âŠƒ(â¬š0âŠâŒŠ|Bell âŠ™0.5 âŠ™0.15 â—¿â‚)
# $     Shift Ã·/+âŠ¸â™­
# $   )
# $ 
# $   # The parameters are as follows:
# $   #  - Cs â† channels = current state
# $   #  - Câ‚€ â† input channel indeces
# $   #  - T â† time scale
# $   #  - R â† kernel radius
# $   #  - Ï â† relative kernel radius
# $   #  - Î² â† kernel peaks
# $   #  - Î¼, Ïƒ, H â† growth centers, -widths & -heights
# $   #  - Câ‚ â† output channel indeces
# $   # Cs ? Cs Câ‚€ R Ï Î² Î¼ Ïƒ H Câ‚ T
# $   U â† â†¥â‚€â†§â‚ +âŸœ(
# $     â§»â¤šâŠ“âŠ¢âŠ™âŠ™âˆ˜ËœâŠ
# $     â‰¡(Convâ—‡Kernel)
# $     ËœÃ·ËœâŠ•/+Ã—-â‚Ã—â‚‚Bell
# $   )
# $ 
# $   # The parameters are as follows:
# $   #  - Cs â† channels = current state
# $   #  - Câ‚€ â† input channel indeces
# $   #  - T â† time scale
# $   #  - R â† kernel radius
# $   #  - Ï â† relative kernel radius
# $   #  - Î² â† kernel peaks
# $   #  - Î¼, Ïƒ, H â† growth centers, -widths & -heights
# $   #  - Câ‚ â† output channel indeces
# $   # anim ? frames Cs Câ‚€ R Ï Î² Î¼ Ïƒ H Câ‚ T
# $   Sim â† â¥âŠƒâŠ¸â‚‰Uâ‰
# $ â””â”€â•´
